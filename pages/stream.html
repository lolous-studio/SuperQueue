<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socket Test Audio</title>
</head>

<body>
    <h2>Click to play...</h2>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>

        class SoundBuffer {
            constructor(ctx, sampleRate, bufferSize = 6, debug = true) {
                this.ctx = ctx;
                this.sampleRate = sampleRate;
                this.bufferSize = bufferSize;
                this.debug = debug;
                this.chunks = [];
                this.isPlaying = false;
                this.startTime = 0;
                this.lastChunkOffset = 0;
            }

            createChunk(chunk) {
                const audioBuffer = this.ctx.createBuffer(1, chunk.length, this.sampleRate);
                audioBuffer.getChannelData(0).set(chunk);
                const source = this.ctx.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.ctx.destination);
                source.onended = () => {
                    this.chunks.shift();
                    if (this.chunks.length === 0) {
                        this.isPlaying = false;
                        this.startTime = 0;
                        this.lastChunkOffset = 0;
                    }
                };
                console.log('Created buffer duration:', audioBuffer.duration); // Log buffer duration
                return source;
            }

            log(data) {
                if (this.debug) {
                    console.log(new Date().toUTCString() + " : " + data);
                }
            }

            addChunk(data) {
                if (this.isPlaying && this.chunks.length > this.bufferSize) {
                    this.log("chunk discarded");
                    return; // throw away
                } else if (this.isPlaying && this.chunks.length <= this.bufferSize) {
                    this.log('chunk accepted');
                    const chunk = this.createChunk(data);
                    console.log('Starting chunk playback');
                    chunk.start(this.startTime + this.lastChunkOffset);
                    this.lastChunkOffset += chunk.buffer.duration;
                    this.chunks.push(chunk);
                } else if (this.chunks.length < this.bufferSize / 2 && !this.isPlaying) {
                    this.log("chunk queued");
                    const chunk = this.createChunk(data);
                    this.chunks.push(chunk);
                } else {
                    this.log("queued chunks scheduled");
                    this.isPlaying = true;
                    const chunk = this.createChunk(data);
                    this.chunks.push(chunk);
                    this.startTime = this.ctx.currentTime;
                    this.lastChunkOffset = 0;
                    this.chunks.forEach((c) => {
                        c.start(this.startTime + this.lastChunkOffset);
                        this.lastChunkOffset += c.buffer.duration;
                    });
                }
            }
        }

        document.body.onclick = () => {
            document.querySelector('h2').innerText = "Trying to play audio rn...";
            const socket = io();

            // Create an audio context
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create a script processor node
            audioContext.audioWorklet.addModule('audio-processor.js')
                .then(() => {
                    const workletNode = new AudioWorkletNode(audioContext, 'audioProcessor');

                    // Create a SoundBuffer instance
                    const soundBuffer = new SoundBuffer(audioContext, 16000);

                    // Connect the script node to the audio context
                    workletNode.connect(audioContext.destination);

                    socket.on('audio', (chunkBuffer) => {
                        console.log('Received audio chunk:', chunkBuffer.byteLength, 'bytes');
                        if (chunkBuffer && chunkBuffer.byteLength > 0) {
                            const int16Array = new Int16Array(chunkBuffer);
                            const float32Array = new Float32Array(int16Array.length);
                            console.log('Int16Array:', int16Array);

                            for (let i = 0; i < int16Array.length; i++) {
                                float32Array[i] = int16Array[i] / 32767.0; // Normalize to [-1, 1]
                            }

                            // Add the converted chunk to the SoundBuffer for playback
                            soundBuffer.addChunk(float32Array);
                        } else {
                            console.error('Received empty or invalid audio chunk.');
                        }
                    });

                })
                .catch((error) => console.error(error));
        };


    </script>
</body>

</html>